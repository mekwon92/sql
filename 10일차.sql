--인덱스 생성에 ROWID 사용됨
SELECT STUDNO, NAME, ROWID, ROWNUM FROM STUDENT s ;

--DEPARTMENT 테이블 DNAME에 고유 인덱스 생성
--인덱스이름은 헝가리안표기법
CREATE INDEX IDX_DEPT_NAME ON DEPARTMENT(DNAME);

--ctrl+shift+e : 실행계획보기
SELECT * FROM DEPARTMENT WHERE DNAME IS NOT NULL ;

--힌트 : 옵티마이저에게 직접 실행 경로를 작성해 주는 것 (학과이름 오름차순)
SELECT /*+ INDEX(D IDX_DEPT_NAME) */ * FROM DEPARTMENT D ;
--INDEX DESC를 PK에 거는 형태로 많이 사용됨?!
SELECT /*+ INDEX_DESC(DEPARTMENT DEPARTMENT_PK) */ * FROM DEPARTMENT ;

--STUDENT BIRTHDATE에 비고유 인덱스 생성
CREATE INDEX IDX_STUD_BIRTHDATE ON STUDENT(BIRTHDATE);

--STUDENT 테이블의 DEPTNO, GRADE에 결합 인덱스 생성
--SELECT DISTINCT GRADE, DEPTNO FROM STUDENT s ; 
CREATE UNIQUE INDEX IDX_STUD_DEPTNO_GRADE ON STUDENT(DEPTNO, GRADE DESC);
--중복된값이 있어서 UNIQUE 불가능
CREATE INDEX IDX_STUD_DEPTNO_GRADE ON STUDENT(DEPTNO, GRADE DESC);

-- 뷰 생성(SYSTEM에서 권한부여 필요)
CREATE OR REPLACE VIEW VIEW_STUD AS
SELECT STUDNO, NAME, DEPTNO FROM STUDENT s ;

SELECT * FROM VIEW_STUD;
SELECT * FROM (SELECT STUDNO, NAME, DEPTNO FROM STUDENT);
--FROM절 서브쿼리와 동일한 결과

--ALTER 대신 CREATE OR REPLACE 사용
CREATE OR REPLACE VIEW VIEW_STUD AS
SELECT STUDNO, NAME, USERID, DEPTNO FROM STUDENT;

SELECT DEPTNO, COUNT(*)
FROM VIEW_STUD
WHERE DEPTNO <> 201
GROUP BY DEPTNO;

INSERT INTO VIEW_STUD VALUES (12345, '홍길동', NULL);
--VIEW에만 추가된게 아니라 학생 테이블에도 추가됨
SELECT * FROM STUDENT s ;

--오탈자가 있어도 강제적으로 처리하는 경우
CREATE FORCE VIEW VIEW_STUD2 AS
SELECT * FROM STUDEN;

--학번, 이름, 학과번호, 학과이름으로 VIEW_STUD_DEPT라는 뷰 생성
CREATE VIEW VIEW_STUD_DEPT AS
SELECT STUDNO, NAME, DEPTNO, DNAME
FROM STUDENT s 
JOIN DEPARTMENT d  USING(DEPTNO);

SELECT * FROM VIEW_STUD_DEPT;

--복합뷰 : 조회는 가능하지만 DML처리는 안됨.
-- 11111, 고길동, 101, 컴퓨터 공학과
INSERT INTO VIEW_STUD_DEPT VALUES (11111,'고길동',101,'컴퓨터공학과'); 

--학과별 인원소를 조회하여 VIEW_STUD_DEPT2 라는 VIEW 생성
CREATE VIEW VIEW_STUD_DEPT2 AS
SELECT DEPTNO, COUNT(*)
FROM STUDENT
GROUP BY DEPTNO 
ORDER BY 1;

CREATE VIEW VIEW_STUD_DEPT2(DNO, CNT) AS
SELECT DEPTNO, COUNT(*)
FROM STUDENT
GROUP BY DEPTNO 
ORDER BY 1;

--인라인 뷰,,,
SELECT * FROM VIEW_STUD_DEPT2;

SELECT * FROM BOARD;

DROP SEQUENCE SEQ_BOARD;
CREATE SEQUENCE SEQ_BOARD;


INSERT INTO BOARD (NO, TITLE, CONTENT, WRITER) 	
	VALUES (SEQ_BOARD.NEXTVAL, '제목'|| SEQ_BOARD.CURRVAL,'내용','작성자');
INSERT INTO BOARD (NO, TITLE, CONTENT, WRITER) 
	SELECT SEQ_BOARD.NEXTVAL,TITLE, CONTENT, WRITER FROM BOARD ;

--한페이지에 몇개씩? 10개!
SELECT * FROM (
	SELECT ROWNUM RN, A.*
		FROM (
			SELECT B.* FROM BOARD B 
			--WHERE ROWNUM <= 10
			ORDER BY 1 DESC
	) A
)
WHERE ROWNUM <= 10 AND RN > (4 - 1) *10;

--RANGE SCAN(범위설정)이 FULL SCAN보다 빠름.
--왜 NO처리가 안되는걸까,,,,,,???
SELECT * FROM (
	SELECT /*+ INDEX_DESC(B SYS_C007058) */ B.*, ROWNUM RN 
	FROM BOARD B
	WHERE NO > 0
);

-- 가독성이 더 좋은 방법
WITH A AS (
	SELECT /*+ INDEX_DESC(B SYS_C007058) */ B.*, ROWNUM RN 
	FROM BOARD B
	WHERE NO > 0
)
SELECT * 
FROM A
WHERE ROWNUM <= 10
AND RN > 10;


--FILE SYSTEM
--FILE의 권한

SELECT * FROM HR.EMPLOYEES;

SELECT SYSDATE FROM DUAL;

--동의어. 별칭과 비슷. 객체로 저장됨
--테이블이나 뷰에도 적용 가능
SELECT * FROM HR.EMPLOYEES; -- 정식 접근
SELECT * FROM HR.EMPLOYEES EMP;

CREATE SYNONYM EMP FOR HR.EMPLOYEES;
SELECT * FROM EMP; -- 이렇게도 접근 가능

CREATE PUBLIC SYNONYM STU FOR SAMPLE.STUDENT;

SELECT * FROM STU;

--데이터 사전
-- 접두어 : USER_ ALL_ DBA_
SELECT * FROM USER_TABLES;

SELECT * FROM ALL_TABLES WHERE OWNER = 'SAMPLE';

SELECT * FROM USER_TAB_COLUMNS WHERE TABLE_NAME = 'BOARD';

SELECT * FROM USER_CONSTRAINTS;
--P : primary C : check R :relational

SELECT * FROM USER_INDEXES;

SELECT * FROM STUDENT s ;




